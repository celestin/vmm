//
// -------------------------------------------------------------
//    Copyright 2004-2009 Synopsys, Inc.
//    All Rights Reserved Worldwide
//
//    Licensed under the Apache License, Version 2.0 (the
//    "License"); you may not use this file except in
//    compliance with the License.  You may obtain a copy of
//    the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in
//    writing, software distributed under the License is
//    distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
//    CONDITIONS OF ANY KIND, either express or implied.  See
//    the License for the specific language governing
//    permissions and limitations under the License.
// -------------------------------------------------------------
//



//------------------------------------------------------------------------------
// CLASS: vmm_ral_block
// Block descriptor class derived from <vmm_ral_block_or_sys>. 
//------------------------------------------------------------------------------
class vmm_ral_block extends vmm_ral_block_or_sys;

   local vmm_ral_reg  regs[$];
   local vmm_ral_vreg vregs[$];
   local vmm_ral_mem  mems[$];


   //------------------------------------------------------------------------------
   // FUNCTION: new
   // Creates an instance of a RAL model with the corresponding block as the top-level structural
   // element. The cover_on argument specifies the functional coverage models to be enabled
   // in the RAL model. 
   // 
   // Multiple functional coverage models may be specified by adding their
   // symbolic names. Only functional coverage models that were generated by ralgen using
   // the -c option can be enabled. Because the functional coverage models affect the memory
   // footprint and runtime performance of a RAL model, they should be enabled only when relevant.
   // 
   // 
   // It is not possible to enable a functional coverage model at a later time, but it is possible
   // to turn the measurement of a functional coverage model off then back on using the <vmm_ral_block::set_cover()>
   // method. 
   //------------------------------------------------------------------------------
   extern function new(vmm_ral_sys                   parent,
                       string                        name,
                       string                        typename,
                       int unsigned                  n_bytes,
                       vmm_ral::endianness_e         endian,
                       bit [`VMM_RAL_ADDR_WIDTH-1:0] base_addr,
                       string                        domain   = "",
                       int                           cover_on = vmm_ral::NO_COVERAGE,
                       int                           has_cover = vmm_ral::NO_COVERAGE,
		       bit                           direction_coverage = 0);

   /*local*/ extern virtual function void Xlock_modelX();
   /*local*/ extern function void register_reg(vmm_ral_reg register);
   /*local*/ extern function void register_vreg(vmm_ral_vreg register);
   /*local*/ extern function void register_mem(vmm_ral_mem memory);
   /*local*/ extern virtual function void Xregister_ral_accessX(vmm_ral_access access);

`ifdef VMM_RAL_FAST_SRCH
   extern local function void Xinit_reg_by_offset_mapX();
   vmm_ral_reg_by_offset_map reg_map_by_domain[*];
   extern /*local*/ function vmm_ral_reg_by_offset_map Xget_reg_by_offset_mapX(string domain); 
`endif


   //------------------------------------------------------------------------------
   // FUNCTION: psdisplay
   // Creates a human-readable description of the block, including the registers
   // and memories it contains. Each line of the description is prefixed with the specified
   // prefix. A description of all domains within the block is created. 
   // 
   // In a multi-domain
   // block, if a description is required only for a specific domain, then you use
   // the <vmm_ral_block::psdisplay_domain> function instead. 
   //------------------------------------------------------------------------------
   extern virtual function string psdisplay(string prefix = "");

   //------------------------------------------------------------------------------
   // FUNCTION: psdisplay_domain
   // Creates a human-readable description of the block, including the registers
   // and memories it contains. Each line of the description is prefixed with the specified
   // prefix. If a domain is specified, only a description of that domain is created. Otherwise,
   // a description of all domains within the block is created. 
   //------------------------------------------------------------------------------
   extern virtual function string psdisplay_domain(string prefix = "",
                                                   string domain = "");


   //------------------------------------------------------------------------------
   // FUNCTION: get_fields
   // Fills the specified dynamic array with the descriptor for all of the fields contained
   // in the block. If a domain is specified, only the fields accessible through
   // the specified domain are returned. The order in which the fields are located in the array
   // is not specified. 
   //------------------------------------------------------------------------------
   extern virtual function void get_fields(ref vmm_ral_field fields[],
                                           input string      domain = ""); 

   //------------------------------------------------------------------------------
   // FUNCTION: get_virtual_fields
   // Fills the specified dynamic array with the descriptor for all of the virtual fields
   // contained in the block. If a domain is specified, only the fields implemented
   // in memories accessible through the specified domain are returned. The order in which
   // the fields are located in the array is not specified. 
   //------------------------------------------------------------------------------
   extern virtual function void get_virtual_fields(ref vmm_ral_vfield fields[],
                                                   input string      domain = ""); 

   //------------------------------------------------------------------------------
   // FUNCTION: get_field_by_name
   // Finds a field with the specified name in the block and returns its descriptor.
   // If no fields are found, returns null. Field name uniqueness is guaranteed only within
   // registers. Therefore, if used on a system or block with more than one field having the
   // same name, this method returns the first field found. 
   //------------------------------------------------------------------------------
   extern virtual function vmm_ral_field get_field_by_name(string name);

   //------------------------------------------------------------------------------
   // FUNCTION: get_virtual_field_by_name
   // Finds a virtual field with the specified name in the block and returns its descriptor.
   // If no fields are found, returns null. Field name uniqueness is guaranteed only within
   // virtual registers. Therefore, if used on a system or block with more than one field having
   // the same name, this method returns the first field found. 
   //------------------------------------------------------------------------------
   extern virtual function vmm_ral_vfield get_virtual_field_by_name(string name);


   //------------------------------------------------------------------------------
   // FUNCTION: get_registers
   // Fills the specified dynamic array with the descriptor for all of the registers contained
   // in the block. If a domain is specified, only the registers accessible by the
   // specified domain are returned. The order in which the registers are located in the array
   // is not specified. 
   //------------------------------------------------------------------------------
   extern virtual function void get_registers(ref vmm_ral_reg regs[],
                                              input string    domain = "");

   //------------------------------------------------------------------------------
   // FUNCTION: get_virtual_registers
   // Fills the specified dynamic array with the descriptor for all of the virtual registers
   // contained in the block. If a domain is specified, only the registers implemented
   // in memories accessible by the specified domain are returned. The order in which the
   // registers are located in the array is not specified. 
   //------------------------------------------------------------------------------
   extern virtual function void get_virtual_registers(ref vmm_ral_vreg vregs[],
                                                      input string    domain = "");
   extern virtual function vmm_ral_reg get_reg_by_name(string name);
   extern virtual function vmm_ral_vreg get_vreg_by_name(string name);

   //------------------------------------------------------------------------------
   // FUNCTION: get_reg_by_offset
   // Finds the register located at the specified offset within the block address
   // space in the specified domain and returns its descriptor. If no register is found at
   // the specified offset, returns NULL. The entire register may occupy more than one offset
   // within the address space of the block if it is wider than the physical interface.
   // In such cases, this function looks for the start (lowest) address of the register's
   // address space. 
   //------------------------------------------------------------------------------
   extern virtual function vmm_ral_reg get_reg_by_offset(bit [`VMM_RAL_ADDR_WIDTH-1:0] offset,
                                                         string                        domain = "");


   //------------------------------------------------------------------------------
   // FUNCTION: get_memories
   // Fills the specified dynamic array with the descriptor for all of the memories contained
   // in the block. If a domain is specified, only those memories accessible in the
   // specified domain are returned. The order in which the memories are located in the array
   // is not specified. 
   //------------------------------------------------------------------------------
   extern virtual function void get_memories(ref vmm_ral_mem mems[],
                                             input string    domain = "");

   //------------------------------------------------------------------------------
   // FUNCTION: get_mem_by_name
   // Finds a memory with the specified name in the block and returns its descriptor.
   // If no memories are found, returns null. Memory name uniqueness is guaranteed only within
   // blocks. Therefore, if used on a system with more than one memory having the same name,
   // this method returns the first memory found. 
   //------------------------------------------------------------------------------
   extern virtual function vmm_ral_mem get_mem_by_name(string name);
   extern virtual function vmm_ral_mem get_mem_by_offset(bit [`VMM_RAL_ADDR_WIDTH-1:0] offset,
                                                         string                        domain = "");


   //------------------------------------------------------------------------------
   // FUNCTION: get_constraints
   // Fills the specified dynamic array with the names of the constraint blocks in this block
   //. Does not include the constraint blocks in the registers or fields in this
   // block. The location of each constraint block name in the array is not defined.
   // 
   //------------------------------------------------------------------------------
   extern virtual function void get_constraints(ref string names[]);


   //------------------------------------------------------------------------------
   // FUNCTION: ral_power_down
   // Specify that this block or all blocks in this system has been put in a power-saving state.
   // A read or write access to any register or memory inside the powered-down block will result
   // in a run-time error message and a vmm_ral::ERROR status code.
   //
   // If the "retain" argument
   // is TRUE, the mirrored value of registers with an inherited non-zero RETAIN attribute
   // value will be maintained and restored when the block is powered back up using the vmm_ral_block::ral_power_up()
   // method.
   //
   // If the retain argument is FALSE, the mirrored value of registers will be set
   // to the reset value when the block is powered back up. A powered-down block with
   // retention enabled can be further powered down with retention disabled.
   //
   // This method
   // does not physically power down the block. It only indicates to the RAL model
   // that the block has been powered down. 
   //------------------------------------------------------------------------------
   extern virtual function void ral_power_down(bit retain = 0);

   //------------------------------------------------------------------------------
   // FUNCTION: ral_power_up
   // Specify that the block or blocks in the system and the memories within them with an inherited
   // POWER_DOMAIN attribute value that matches the specified power domain regular expression
   // have been restored to a powered-up state.
   //
   // If the power domain is specified as "", then
   // the block or blocks in the system and any memory within them are powered up regardless
   // of the POWER_DOMAIN attribute value.
   //
   // If a block was as powered down using the vmm_ral_block::ral_power_down()
   // method with a "retain" argument specified as TRUE, the mirrored value of registers
   // with an inherited non-zero RETAIN attribute value is restored.
   //
   // Otherwise, the mirrored
   // value of registers is set to the specified reset value. By default, a block
   // is powered-up.
   //
   // This method does not physically power up the block.
   //
   // It only
   // indicates to the RAL model that the block has been powered up. 
   //------------------------------------------------------------------------------
   extern virtual function void ral_power_up(string power_domains = "");
   /*local*/ bit Xis_powered_downX;
   local bit is_powered_down_with_retention;


   //------------------------------------------------------------------------------
   // FUNCTION: set_cover
   // Turns the collection of functional coverage measurements on or off for this block or
   // system and all subsystems, blocks, registers, fields and memories within it. The functional
   // coverage measurement is turned on for every coverage model specified.
   //
   // Multiple functional
   // coverage models can be specified by adding the functional coverage model identifiers.
   // All other functional coverage models are turned off.
   //
   // Returns the sum of all functional
   // coverage models whose measurements were previously on.
   //
   // This method can only control
   // the measurement of functional coverage models that have been generated by ralgen
   // then enabled when calling <vmm_ral_block::new()>
   // or <vmm_ral_sys::new()>. See the <vmm_ral_block::has_cover()> method to identify
   // the available functional coverage models. 
   //------------------------------------------------------------------------------
   extern virtual function int set_cover(int is_on);


   //------------------------------------------------------------------------------
   // FUNCTION: reset
   // Sets the mirror value of all registers in the block to the specified hard or
   // soft reset value. Does not actually set the value of the registers in the design, only
   // the values mirrored in their corresponding descriptor in the RAL model. If a domain
   // is specified, only those registers accessible through the specified domain are reset.
   // The mirror values of memories is not modified. 
   //------------------------------------------------------------------------------
   extern virtual function void reset(string           domain = "",
                                      vmm_ral::reset_e kind   = vmm_ral::HARD);

   //------------------------------------------------------------------------------
   // FUNCTION: needs_update
   // If a mirror value has been modified in the RAL model without actually updating the actual
   // register, the mirror and state of the registers are outdated. This method returns TRUE
   // if the state of the registers needs to be updated to match the mirrored values (or vice-versa).
   // The mirror values, or actual content of registers, are not modified.
   //
   // For additional
   // information, see <vmm_ral_block::update()> or <vmm_ral_block::mirror()>. 
   //------------------------------------------------------------------------------
   extern virtual function bit needs_update();


   //------------------------------------------------------------------------------
   // TASK: update
   // Using the minimum number of write operations, updates the content of the registers
   // in the design to match the mirrored values.
   //
   // The update can be performed using the physical
   // interfaces (front-door access) or back-door (zero-time) access.
   //
   // This method performs
   // the reverse operation of <vmm_ral_block::mirror()>. 
   //------------------------------------------------------------------------------
   extern virtual task update(output vmm_rw::status_e status,
                              input  vmm_ral::path_e  path = vmm_ral::DEFAULT,
                              input  string           fname = "",
                              input  int              lineno = 0);

   //------------------------------------------------------------------------------
   // TASK: mirror
   // Updates the content of the registers mirror values to match their corresponding values
   // in the design. The mirroring can be performed using the physical interfaces (front-door
   // access) or back-door (zero-time) access.
   //
   // If the check argument is specified as vmm_ral::VERB,
   // an error message is issued if the current mirrored value does not match the actual value
   // in the design.
   //
   // This method performs the reverse operation of <vmm_ral_block::update()>.
   // 
   //------------------------------------------------------------------------------
   extern virtual task mirror(output vmm_rw::status_e status,
                              input  vmm_ral::check_e check = vmm_ral::QUIET,
                              input  vmm_ral::path_e  path  = vmm_ral::DEFAULT,
                              input  string           fname = "",
                              input  int              lineno = 0);
   

   //------------------------------------------------------------------------------
   // TASK: readmemh
   // Not yet implemented. Initializes the content of all registers and memories in the design
   // using the values in the specified file.
   //
   // The values are updated using the default access
   // path. See <vmm_ral_block::writememh()> for details. The format of the file is not
   // specified. 
   //------------------------------------------------------------------------------
   extern virtual task readmemh(string filename);

   //------------------------------------------------------------------------------
   // TASK: writememh
   // Not yet implemented. Dumps the content of all registers and memories in the design to
   // the specified file.
   //
   // The file can then be used as an input for the <vmm_ral_block::readmemh()>
   // method. The values are obtained using the default access path. The format of the file
   // is not specified. 
   //------------------------------------------------------------------------------
   extern virtual task writememh(string filename);

   extern virtual /*local*/ function void XsampleX(bit [`VMM_RAL_ADDR_WIDTH-1:0] addr,
                                                   int                           domain,
						   bit                           is_read);
   extern protected virtual function void sample(bit [`VMM_RAL_ADDR_WIDTH-1:0] addr,
                                                 int                           domain);
   extern protected virtual function void sample2(bit [`VMM_RAL_ADDR_WIDTH-1:0] addr,
                                                 int                           domain,
						 bit                           is_read);

   extern function int unsigned get_block_ID(); 

   extern virtual function int unsigned get_block_or_sys_size(string domain = "");


   //------------------------------------------------------------------------------
   // FUNCTION: set_offset
   // Dynamically relocate the base address of the specified domain in the block or subsystem
   // in the address space of the immediately instantiating system. The new address range
   // for the block or subsystem must not be occupied by another block or subsystem. Note that
   // after using this method, the behavior of the RAL model will be different from the RALF
   // specification.
   //
   // Returns TRUE of the relocation was succesful.
   //
   // Returns FALSE if the
   // specified domain does not exist in the immediately enclosing system or the new base
   // address creates an overlap between this block or subsystem address range and another
   // block or subsystem.
   //
   // It is not possible to relocate the base address of the top-level
   // system because is it not instantiated anywhere. 
   //------------------------------------------------------------------------------
   extern virtual function bit set_offset(bit [`VMM_RAL_ADDR_WIDTH-1:0] offset,
                                          string domain = "");


   //------------------------------------------------------------------------------
   // FUNCTION: sample_field_values
   // By using this function, you can sample the field value coverage within the RAL registers.
   // In the generated code, it will be extended to call field_values.sample() for all the
   // registers for which you have the "field value" coverage enabled. 
   //------------------------------------------------------------------------------
   extern virtual function void sample_field_values();

endclass: vmm_ral_block
   

function vmm_ral_block::new(vmm_ral_sys                   parent,
                            string                        name,
                            string                        typename,
                            int unsigned                  n_bytes,
                            vmm_ral::endianness_e         endian,
                            bit [`VMM_RAL_ADDR_WIDTH-1:0] base_addr,
                            string                        domain = "",
                            int                           cover_on  = vmm_ral::NO_COVERAGE,
                            int                           has_cover  = vmm_ral::NO_COVERAGE,
			    bit                           direction_coverage = 0);
   super.new(parent, "RAL Block", name, typename,
             n_bytes, endian, base_addr, domain,
             cover_on, has_cover, direction_coverage);
   this.Xis_powered_downX = 0;
endfunction: new


function void vmm_ral_block::Xlock_modelX();
   if (this.Xis_lockedX()) return;

   super.Xlock_modelX();
   foreach (this.regs[i]) begin
      this.regs[i].Xlock_modelX();
   end
   foreach (this.mems[i]) begin
      this.mems[i].Xlock_modelX();
   end

`ifdef VMM_RAL_FAST_SRCH
   this.Xinit_reg_by_offset_mapX();
`endif
endfunction: Xlock_modelX


`ifdef VMM_RAL_FAST_SRCH
function void vmm_ral_block::Xinit_reg_by_offset_mapX();
   string domains[];
   this.get_domains(domains);
   foreach (domains[i]) begin
      vmm_ral_reg  regs[];
      this.reg_map_by_domain[i] = new;

      this.get_registers(regs, domains[i]);
      foreach (regs[l]) begin
         bit [`VMM_RAL_ADDR_WIDTH-1:0] offset_in_blk 
            = regs[l].get_offset_in_block(domains[i]);
         this.reg_map_by_domain[i].reg_by_offset[offset_in_blk] = regs[l];
      end
   end
endfunction


function vmm_ral_reg_by_offset_map vmm_ral_block::Xget_reg_by_offset_mapX(string domain); 
   int j = this.get_domain_index(domain);
   if (j < 0) begin
      `vmm_warning(this.log, $psprintf("Unable to locate domain \"%s\" in Block \"%s\".",
                                       domain, this.get_fullname()));
      return null;
   end
   if (this.reg_map_by_domain.exists(j)) return this.reg_map_by_domain[j];
   `vmm_warning(this.log, $psprintf("Unable to locate 'reg_by_offset_map' in domain \"%s\" of Block \"%s\".",
                                     domain, this.get_fullname()));
   return null;
endfunction
`endif


function void vmm_ral_block::register_reg(vmm_ral_reg register);
   if (this.Xis_lockedX()) begin
      `vmm_error(this.log, "Cannot add register to locked block model");
      return;
   end

   // Check if this register has already been registered with this block
   foreach (this.regs[i]) begin
      if (this.regs[i] == register) begin
         `vmm_error(this.log, $psprintf("Register \"%s\" has already been registered with block \"%s\".\n",
                                       register.get_name(), this.get_name()));
         return;
      end
   end
   this.regs.push_back(register);
endfunction: register_reg

function void vmm_ral_block::register_vreg(vmm_ral_vreg register);
   if (this.Xis_lockedX()) begin
      `vmm_error(this.log, "Cannot add virtual register to locked block model");
      return;
   end

   // Check if this register has already been registered with this block
   foreach (this.vregs[i]) begin
      if (this.vregs[i] == register) begin
         `vmm_error(this.log, $psprintf("Virtual register \"%s\" has already been registered with block \"%s\".\n",
                                       register.get_name(), this.get_name()));
         return;
      end
   end
   this.vregs.push_back(register);
endfunction: register_vreg

function void vmm_ral_block::register_mem(vmm_ral_mem memory);
   if (this.Xis_lockedX()) begin
      `vmm_error(this.log, "Cannot add memory to locked block model");
      return;
   end

   // Check if this memory has already been registered with this block
   foreach (this.mems[i]) begin
      if (this.mems[i] == memory) begin
         `vmm_error(this.log, $psprintf("Memory \"%s\" has already been registered with block \"%s\".\n",
                                       memory.get_name(), this.get_name()));
         return;
      end
   end
   this.mems.push_back(memory);
endfunction: register_mem


function void vmm_ral_block::Xregister_ral_accessX(vmm_ral_access access);
   // There can only be one RAL Access on a RAL model
   if (this.ral_access != null && this.ral_access != access) begin
      `vmm_fatal(this.log, $psprintf("Block %s is already used by another RAL access instance", this.get_fullname()));
   end
   this.ral_access = access;

   // Register all sub-elements
   begin
      vmm_ral_reg  regs[];
      vmm_ral_mem  mems[];

      this.get_registers(regs);
      foreach (regs[i]) begin
         regs[i].Xregister_ral_accessX(access);
      end

      this.get_memories(mems);
      foreach (mems[i]) begin
         mems[i].Xregister_ral_accessX(access);
      end
   end
endfunction: Xregister_ral_accessX


function string vmm_ral_block::psdisplay(string prefix = "");
   return psdisplay_domain(prefix);
endfunction

function string vmm_ral_block::psdisplay_domain(string prefix = "",
                                                string domain = "");
   string       domains[];
   vmm_ral_reg  regs[];
   vmm_ral_vreg vregs[];
   vmm_ral_mem  mems[];
   bit          single_domain;
   vmm_ral::endianness_e endian;

   single_domain = 1;
   if (domain == "") begin
      this.get_domains(domains);
      if (domains.size() > 1) single_domain = 0;
   end
   if (single_domain) begin
      $sformat(psdisplay_domain, "%sBlock %s", prefix, this.get_fullname());
      if (domain != "") $sformat(psdisplay_domain, "%s.%s", psdisplay_domain, domain);
      endian = this.get_endian(domain);
      $sformat(psdisplay_domain, "%s -- %0d bytes (%s)", psdisplay_domain,
               this.get_n_bytes(domain), endian.name());
      this.get_registers(regs, domain);
      foreach (regs[j]) begin
         $sformat(psdisplay_domain, "%s\n%s", psdisplay_domain,
                  regs[j].psdisplay_domain({prefix, "   "}, domain));
      end
      this.get_virtual_registers(vregs, domain);
      foreach (vregs[j]) begin
         $sformat(psdisplay_domain, "%s\n%s", psdisplay_domain,
                  vregs[j].psdisplay_domain({prefix, "   "}, domain));
      end
      this.get_memories(mems, domain);
      foreach (mems[j]) begin
         $sformat(psdisplay_domain, "%s\n%s", psdisplay_domain,
                  mems[j].psdisplay_domain({prefix, "   "}, domain));
      end
   end
   else begin
      $sformat(psdisplay_domain, "%sBlock %s", prefix, this.get_fullname());
      foreach (domains[i]) begin
         endian = this.get_endian(domains[i]);
         $sformat(psdisplay_domain, "%s\n%s   Domain \"%s\" -- %0d bytes (%s)",
                  psdisplay_domain, prefix, domains[i],
                  this.get_n_bytes(domains[i]), endian.name());
         this.get_registers(regs, domains[i]);
         foreach (regs[j]) begin
            $sformat(psdisplay_domain, "%s\n%s", psdisplay_domain,
                     regs[j].psdisplay_domain({prefix, "      "},
                                       domains[i]));
         end
         this.get_virtual_registers(vregs, domains[i]);
         foreach (vregs[j]) begin
            $sformat(psdisplay_domain, "%s\n%s", psdisplay_domain,
                     vregs[j].psdisplay_domain({prefix, "      "},
                                       domains[i]));
         end
         this.get_memories(mems, domains[i]);
         foreach (mems[j]) begin
            $sformat(psdisplay_domain, "%s\n%s", psdisplay_domain,
                     mems[j].psdisplay_domain({prefix, "      "}, domains[i]));
         end
      end
   end
endfunction: psdisplay_domain


function void vmm_ral_block::get_fields(ref vmm_ral_field fields[],
                                        input string      domain = "");
   int n;
   vmm_ral_reg r[];
   vmm_ral_field f[];

   fields = new [0];
   this.get_registers(r, domain);
   foreach (r[i]) begin
      r[i].get_fields(f);
      n = fields.size();
      fields = new [n + f.size()] (fields);

      foreach (f[j]) begin
         fields[n++] = f[j];
      end
   end
endfunction: get_fields

function void vmm_ral_block::get_virtual_fields(ref vmm_ral_vfield fields[],
                                                input string      domain = "");
   int n;
   vmm_ral_vreg r[];
   vmm_ral_vfield f[];

   fields = new [0];
   this.get_virtual_registers(r, domain);
   foreach (r[i]) begin
      r[i].get_fields(f);
      n = fields.size();
      fields = new [n + f.size()] (fields);

      foreach (f[j]) begin
         fields[n++] = f[j];
      end
   end
endfunction: get_virtual_fields

function vmm_ral_field vmm_ral_block::get_field_by_name(string name);
   // Search the registers to find the first field of the specified name
   foreach (this.regs[i]) begin
      vmm_ral_field fields[];
      this.regs[i].get_fields(fields);
      foreach (fields[j]) begin
         if (fields[j].get_name() == name) begin
            return fields[j];
         end
      end
   end
   `vmm_warning(this.log, $psprintf("Unable to locate field \"%s\" in block \"%s\".",
                                    name, this.get_fullname()));
   get_field_by_name = null;
endfunction: get_field_by_name

function vmm_ral_vfield vmm_ral_block::get_virtual_field_by_name(string name);
   // Search the registers to find the first field of the specified name
   foreach (this.vregs[i]) begin
      vmm_ral_vfield fields[];
      this.vregs[i].get_fields(fields);
      foreach (fields[j]) begin
         if (fields[j].get_name() == name) begin
            return fields[j];
         end
      end
   end
   `vmm_warning(this.log, $psprintf("Unable to locate virtual field \"%s\" in block \"%s\".",
                                    name, this.get_fullname()));
   get_virtual_field_by_name = null;
endfunction: get_virtual_field_by_name


function void vmm_ral_block::get_registers(ref vmm_ral_reg regs[],
                                           input string    domain = "");
   if (domain == "") begin
      regs = new [this.regs.size()];
      foreach(this.regs[i]) begin
         regs[i] = this.regs[i];
      end
   end
   else begin
      int n = 0;
      regs = new [this.regs.size()];
      foreach(this.regs[i]) begin
         // Is the register in the specified domain?
         string domains[];
         this.regs[i].get_domains(domains);
         foreach(domains[j]) begin
            if (domains[j] == domain) begin
               regs[n++] = this.regs[i];
               break;
            end
         end
      end
      regs = new [n] (regs);
   end
endfunction: get_registers

function void vmm_ral_block::get_virtual_registers(ref vmm_ral_vreg vregs[],
                                                   input string    domain = "");
   if (domain == "") begin
      vregs = new [this.vregs.size()];
      foreach(this.vregs[i]) begin
         vregs[i] = this.vregs[i];
      end
   end
   else begin
      int n = 0;
      vregs = new [this.vregs.size()];
      foreach(this.vregs[i]) begin
         // Is the register in the specified domain?
         string domains[];
         if(this.vregs[i].get_memory() != null)
         begin
           this.vregs[i].get_domains(domains);
           foreach(domains[j]) begin
              if (domains[j] == domain) begin
                 vregs[n++] = this.vregs[i];
                 break;
              end
           end
         end
      end
      vregs = new [n] (vregs);
   end
endfunction: get_virtual_registers

function vmm_ral_reg vmm_ral_block::get_reg_by_name(string name);
   foreach (this.regs[i]) begin
      if (this.regs[i].get_name() == name) begin
         return this.regs[i];
      end
   end
   `vmm_warning(this.log, $psprintf("Unable to locate register \"%s\" in block \"%s\".",
                                    name, this.get_fullname()));
   get_reg_by_name = null;
endfunction: get_reg_by_name

function vmm_ral_vreg vmm_ral_block::get_vreg_by_name(string name);
   foreach (this.vregs[i]) begin
      if (this.vregs[i].get_name() == name) begin
         return this.vregs[i];
      end
   end
   `vmm_warning(this.log, $psprintf("Unable to locate virtual register \"%s\" in block \"%s\".",
                                    name, this.get_fullname()));
   get_vreg_by_name = null;
endfunction: get_vreg_by_name

function vmm_ral_reg vmm_ral_block::get_reg_by_offset(bit [`VMM_RAL_ADDR_WIDTH-1:0] offset,
                                                      string                        domain = "");
   vmm_ral_reg regs[];

   this.get_registers(regs, domain);
   foreach (regs[i]) begin
      if (regs[i].get_offset_in_block(domain) == offset) begin
         return regs[i];
      end
   end
   `vmm_warning(this.log, $psprintf("Unable to locate register at offset 0x%h %0sin block \"%s\".",
                                    offset, ((domain == "") ? "" : $psprintf("in domain \"%s\" ",
                                                                             domain)),
                                    this.get_fullname()));
   get_reg_by_offset = null;
endfunction: get_reg_by_offset


function void vmm_ral_block::get_memories(ref vmm_ral_mem mems[],
                                          input string    domain = "");
   if (domain == "") begin
      mems = new [this.mems.size()];
      foreach(this.mems[i]) begin
         mems[i] = this.mems[i];
      end
   end
   else begin
      int n = 0;
      mems = new [this.mems.size()];
      foreach(this.mems[i]) begin
         // Is the memory in the specified domain?
         string domains[];
         this.mems[i].get_domains(domains);
         foreach(domains[j]) begin
            if (domains[j] == domain) begin
               mems[n++] = this.mems[i];
               break;
            end
         end
      end
      mems = new [n] (mems);
   end
endfunction: get_memories


function vmm_ral_mem vmm_ral_block::get_mem_by_name(string name);
   foreach (this.mems[i]) begin
      if (this.mems[i].get_name() == name) begin
         return this.mems[i];
      end
   end
   `vmm_warning(this.log, $psprintf("Unable to locate memory \"%s\" in block \"%s\".",
                                    name, this.get_fullname()));
   get_mem_by_name = null;
endfunction: get_mem_by_name


function vmm_ral_mem vmm_ral_block::get_mem_by_offset(bit [`VMM_RAL_ADDR_WIDTH-1:0] offset,
                                                      string                        domain ="");
   //get_mem_by_offset = this.mems.first() with index: (this.mems[index].offset_in_block == offset);
endfunction: get_mem_by_offset


function void vmm_ral_block::get_constraints(ref string names[]);
endfunction: get_constraints


function void vmm_ral_block::ral_power_down(bit retain = 0);
   vmm_ral_mem mems[];

   if (this.Xis_powered_downX) begin
      // It's OK to insist that the block is powered down, but
      // you can't get state retention if it was previously powered down without it
      if (!this.is_powered_down_with_retention && retain) begin
         `vmm_error(this.log, $psprintf("Cannot power-down memory \"%s\" with retention because is has already been powered down without retention",
                                        this.get_fullname()));
         return;
      end
   end

   // Power down all memories
   this.get_memories(mems);
   foreach (mems[i]) begin
      mems[i].ral_power_down();
   end

   this.Xis_powered_downX = 1;
   this.is_powered_down_with_retention = retain;
endfunction: ral_power_down


function void vmm_ral_block::ral_power_up(string power_domains = "");
   vmm_ral_reg  regs[];
   vmm_ral_mem  mems[];
   string       pwr_domain;

   if (power_domains != "") begin
      pwr_domain = this.get_attribute("POWER_DOMAIN");
      if (!`vmm_str_match(pwr_domain, power_domains)) return;
   end

   // Initialize registers based on powered-down retention
   this.get_registers(regs);
   foreach (regs[i]) begin
      if (!this.is_powered_down_with_retention) regs[i].reset();
      else begin
         string retain_attrib = regs[i].get_attribute("RETAIN");
         if (retain_attrib == "" ||
             retain_attrib == "0") regs[i].reset();
      end
   end

   // Power up memories in the specified power domains
   this.get_memories(mems);
   foreach (mems[i]) begin
      if (power_domains != "") begin
         pwr_domain = mems[i].get_attribute("POWER_DOMAIN");
         if (!`vmm_str_match(pwr_domain, power_domains)) continue;
      end
      mems[i].ral_power_up();
   end
   
   this.Xis_powered_downX = 0;
endfunction: ral_power_up


function int vmm_ral_block::set_cover(int is_on);
   int can_cvr;

   set_cover = super.set_cover(is_on);
   can_cvr = is_on & set_cover;
   if (can_cvr == 0) return set_cover;

   foreach (this.regs[i]) begin
      void'(this.regs[i].set_cover(can_cvr));
   end
   foreach (this.mems[i]) begin
      void'(this.mems[i].set_cover(can_cvr));
   end
endfunction: set_cover


function void vmm_ral_block::reset(string           domain = "",
                                   vmm_ral::reset_e kind = vmm_ral::HARD);
   vmm_ral_reg regs[];
   vmm_ral_mem mems[];

   this.get_registers(regs, domain);
   foreach (regs[i]) begin
      regs[i].reset(kind);
   end

   this.get_memories(mems, domain);
   foreach (mems[i]) begin
      vmm_ral_vreg vregs[];
      mems[i].get_virtual_registers(vregs);
      foreach (vregs[j]) begin
         vregs[j].reset(kind);
      end
   end
endfunction: reset


function bit vmm_ral_block::needs_update();
   needs_update = 0;
   foreach (this.regs[i]) begin
      if (this.regs[i].needs_update()) begin
         return 1;
      end
   end
endfunction: needs_update


task vmm_ral_block::update(output vmm_rw::status_e status,
                           input  vmm_ral::path_e  path = vmm_ral::DEFAULT,
                           input  string           fname = "",
                           input  int              lineno = 0);
   string domains[];
   bit    updated;
  `vmm_debug(this.log, $psprintf("%s:%0d; updating ral block %s with %s path",
                                  fname, lineno, this.get_name(), path.name ));


   status = vmm_rw::IS_OK;
   foreach (this.regs[i]) begin
      if (!this.regs[i].needs_update()) continue;

      this.regs[i].get_domains(domains);

      if (path == vmm_ral::BACKDOOR) begin
         this.regs[i].update(status, path, domains[0]);
         if (status == vmm_rw::IS_OK || status == vmm_rw::HAS_X) continue;
         `vmm_error(this.log, $psprintf("Register \"%s\" could not be updated",
                                        regs[i].get_fullname()));
         return;
      end

      // Find the first writeable domain to
      // perform the update through
      updated = 0;
      foreach (domains[j]) begin
         if (this.regs[i].get_rights(domains[j]) != vmm_ral::RO) begin
            this.regs[i].update(status, path, domains[j]);
            if (status == vmm_rw::IS_OK || status == vmm_rw::HAS_X) begin
               updated = 1;
               break;
            end
         end
      end
      if (!updated) begin
         `vmm_error(this.log, $psprintf("Register \"%s\" could not be updated",
                                        regs[i].get_fullname()));
         if (status == vmm_rw::IS_OK || status == vmm_rw::HAS_X) status = vmm_rw::ERROR;
         return;
      end
   end
endtask: update


task vmm_ral_block::mirror(output vmm_rw::status_e status,
                           input  vmm_ral::check_e check = vmm_ral::QUIET,
                           input  vmm_ral::path_e  path = vmm_ral::DEFAULT,
                           input  string           fname = "",
                           input  int              lineno = 0);
   string domains[];
   bit mirrored;

   status = vmm_rw::IS_OK;
   foreach (this.regs[i]) begin

      if (path == vmm_ral::BACKDOOR) begin
         this.regs[i].mirror(status, check, path,"", fname, lineno);
         if (status != vmm_rw::IS_OK && status != vmm_rw::HAS_X) return;
         continue;
      end

      // Find the first readable domain to
      // perform the update through
      this.regs[i].get_domains(domains);
      mirrored = 0;
      foreach (domains[j]) begin
         if (this.regs[i].get_rights(domains[j]) != vmm_ral::WO) begin
            this.regs[i].mirror(status, check, path, domains[0], fname, lineno);
            if (status == vmm_rw::IS_OK || status == vmm_rw::HAS_X) begin
               mirrored = 1;
               break;
            end
         end
      end
      if (!mirrored) begin
         `vmm_error(this.log, $psprintf("Register \"%s\" could not be mirrored",
                                        regs[i].get_fullname()));
         if (status == vmm_rw::IS_OK || status == vmm_rw::HAS_X) status = vmm_rw::ERROR;
         return;
      end
   end
endtask: mirror


task vmm_ral_block::readmemh(string filename);
endtask: readmemh


task vmm_ral_block::writememh(string filename);
endtask: writememh


function void vmm_ral_block::XsampleX(bit [`VMM_RAL_ADDR_WIDTH-1:0] addr,
                                      int                           domain,
				      bit                           is_read);
   this.sample2(addr, domain, is_read);
endfunction


function void vmm_ral_block::sample(bit [`VMM_RAL_ADDR_WIDTH-1:0] addr,
                                    int                           domain);
   // Nothing to do in this base class
endfunction

function void vmm_ral_block::sample2(bit [`VMM_RAL_ADDR_WIDTH-1:0] addr,
                                    int                           domain,
				    bit                           is_read);
   this.sample(addr, domain);
endfunction

function bit vmm_ral_block::set_offset(bit [`VMM_RAL_ADDR_WIDTH-1:0] offset,
                                       string domain = "");
  int j;
  vmm_ral_sys parent_sys;
  string parent_domain;

  set_offset = 0;
  j = this.get_domain_index(domain);
  if (j < 0)
  begin
     `vmm_warning(this.log, $psprintf("Unable to locate domain \"%s\" in Block \"%s\".",
                                      domain, this.get_fullname()));
     return 0;
  end

  if(this.get_parent() != null)
  begin
    parent_sys = this.get_parent();
    parent_domain = this.get_parent_domain(domain);
    if(!parent_sys.Xcheck_child_overlapX(offset,this.get_block_or_sys_size(domain),parent_domain,this,null))
    begin
     `vmm_error(this.log,$psprintf("set_offset for %s failed",this.get_fullname()));
      return 0;
    end
    return this.Xset_base_addrX(offset,domain);
  end

  if (offset != 0) begin
    `vmm_error(this.log, $psprintf("Cannot set offset for top-level block \"%s\": must always be 0.",
                                   this.get_fullname()));
  end

  return 0;
endfunction


function int unsigned vmm_ral_block::get_block_or_sys_size(string domain = "");

  vmm_ral_reg regs[];
  vmm_ral_mem mems[];
  int j;
  int unsigned max_addr = 0;
  int unsigned size     = 1;

  j = this.get_domain_index(domain);
  if (j < 0)
  begin
     `vmm_warning(this.log, $psprintf("Unable to locate domain \"%s\" in Block \"%s\".",
                                      domain, this.get_fullname()));
     get_block_or_sys_size = 0;
     return 0;
  end


  this.get_registers(regs,domain);
  this.get_memories(mems,domain);

  foreach (regs[i])
  begin
    int unsigned offset_blk;
    offset_blk = regs[i].get_offset_in_block(domain);
    if (offset_blk > max_addr)
    begin
      max_addr = offset_blk + ((regs[i].get_n_bytes()-1)/this.get_n_bytes(domain));
    end
  end

  foreach (mems[i])
  begin
    int unsigned offset_blk;
    offset_blk = mems[i].get_offset_in_block(0,domain);
    if (offset_blk > max_addr)
    begin
      max_addr = offset_blk + (mems[i].get_size() * (((mems[i].get_n_bytes()-1)/this.get_n_bytes(domain))+1)) -1;
    end
  end

  get_block_or_sys_size = max_addr + 1;

endfunction : get_block_or_sys_size

function int unsigned vmm_ral_block::get_block_ID(); 
   get_block_ID =  this.get_block_or_sys_ID();
endfunction

function vmm_ral_block vmm_ral_get_block_by_ID(int unsigned id);
   vmm_ral_block blk;
   vmm_ral_block_or_sys blk_or_sys;

   blk_or_sys = vmm_ral_get_block_or_sys_by_ID(id);
   if ($cast(blk, blk_or_sys)) vmm_ral_get_block_by_ID = blk;
   else vmm_ral_get_block_by_ID = null;
endfunction

function void vmm_ral_block::sample_field_values();
   `vmm_warning(this.log, $psprintf("Block \"%s\" - Cannot sample field values because the corresponding coverage model was not generated for this block.", this.get_fullname()));
endfunction
